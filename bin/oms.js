// Generated by CoffeeScript 1.6.2
/** @preserve OverlappingMarkerSpiderfier
https://github.com/jaredhobbs/OverlappingMarkerSpiderfier
Copyright (c) 2011 - 2012 George MacKerron
Released under the MIT licence: http://opensource.org/licenses/mit-license
Mapstraction port by Jared Hobbs
Note: The Mapstraction API must be included *before* this code
*/


(function() {
  var __hasProp = {}.hasOwnProperty,
    __slice = [].slice;

  if (this['mxn'] == null) {
    return;
  }

  this['OverlappingMarkerSpiderfier'] = (function() {
    var lcH, lcU, p, twoPi;

    p = _Class.prototype;

    p['VERSION'] = '0.3.1';

    twoPi = Math.PI * 2;

    p['keepSpiderfied'] = false;

    p['markersWontHide'] = false;

    p['markersWontMove'] = false;

    p['nearbyDistance'] = 20;

    p['circleSpiralSwitchover'] = 9;

    p['circleFootSeparation'] = 23;

    p['circleStartAngle'] = twoPi / 12;

    p['spiralFootSeparation'] = 26;

    p['spiralLengthStart'] = 11;

    p['spiralLengthFactor'] = 4;

    p['spiderfiedZIndex'] = 1000;

    p['usualLegZIndex'] = 10;

    p['highlightedLegZIndex'] = 20;

    p['legWeight'] = 1.5;

    p['legColors'] = {
      'usual': {},
      'highlighted': {}
    };

    lcU = p['legColors']['usual'];

    lcH = p['legColors']['highlighted'];

    lcU[mxn.Mapstraction.HYBRID] = lcU[mxn.Mapstraction.SATELLITE] = '#FFFFFF';

    lcH[mxn.Mapstraction.HYBRID] = lcH[mxn.Mapstraction.SATELLITE] = '#F00F00';

    lcU[mxn.Mapstraction.PHYSICAL] = lcU[mxn.Mapstraction.ROAD] = '#444444';

    lcH[mxn.Mapstraction.PHYSICAL] = lcH[mxn.Mapstraction.ROAD] = '#F00F00';

    function _Class(map, opts) {
      var k, v,
        _this = this;

      this.map = map;
      if (opts == null) {
        opts = {};
      }
      for (k in opts) {
        if (!__hasProp.call(opts, k)) continue;
        v = opts[k];
        this[k] = v;
      }
      this.initMarkerArrays();
      this.listeners = {};
      this.map.click.addHandler(function() {
        return _this['unspiderfy']();
      });
      this.map.changeZoom.addHandler(function() {
        return _this['unspiderfy']();
      });
    }

    p.initMarkerArrays = function() {
      this.markers = [];
      return this.markerListenerRefs = [];
    };

    p['addMarker'] = function(marker) {
      var markerListener,
        _this = this;

      if (marker['_oms'] != null) {
        return this;
      }
      marker['_oms'] = true;
      markerListener = function() {
        return _this.spiderListener(marker);
      };
      marker.click.addHandler(markerListener);
      this.markerListenerRefs.push(markerListener);
      this.markers.push(marker);
      return this;
    };

    p.markerChangeListener = function(marker, positionChanged) {
      if ((marker['_omsData'] != null) && (positionChanged || !marker.getVisible()) && !((this.spiderfying != null) || (this.unspiderfying != null))) {
        return this.unspiderfy(positionChanged ? marker : null);
      }
    };

    p['getMarkers'] = function() {
      return this.markers.slice(0);
    };

    p['removeMarker'] = function(marker) {
      var i, markerListener;

      if (marker['_omsData'] != null) {
        this['unspiderfy']();
      }
      i = this.arrIndexOf(this.markers, marker);
      if (i < 0) {
        return this;
      }
      markerListener = this.markerListenerRefs.splice(i, 1)[0];
      marker.removeEventListener('click', markerListener);
      delete marker['_oms'];
      this.markers.splice(i, 1);
      return this;
    };

    p['clearMarkers'] = function() {
      var i, marker, markerListener, _i, _len, _ref;

      this['unspiderfy']();
      _ref = this.markers;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        marker = _ref[i];
        markerListener = this.markerListenerRefs[i];
        marker.removeEventListener('click', markerListener);
        delete marker['_oms'];
      }
      this.initMarkerArrays();
      return this;
    };

    p['addListener'] = function(event, func) {
      var _base, _ref;

      ((_ref = (_base = this.listeners)[event]) != null ? _ref : _base[event] = []).push(func);
      return this;
    };

    p['removeListener'] = function(event, func) {
      var i;

      i = this.arrIndexOf(this.listeners[event], func);
      if (!(i < 0)) {
        this.listeners[event].splice(i, 1);
      }
      return this;
    };

    p['clearListeners'] = function(event) {
      this.listeners[event] = [];
      return this;
    };

    p.trigger = function() {
      var args, event, func, _i, _len, _ref, _ref1, _results;

      event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      _ref1 = (_ref = this.listeners[event]) != null ? _ref : [];
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        func = _ref1[_i];
        _results.push(func.apply(null, args));
      }
      return _results;
    };

    p.generatePtsCircle = function(count, centerPt) {
      var angle, angleStep, circumference, i, legLength, _i, _results;

      circumference = this['circleFootSeparation'] * (2 + count);
      legLength = circumference / twoPi;
      angleStep = twoPi / count;
      _results = [];
      for (i = _i = 0; 0 <= count ? _i < count : _i > count; i = 0 <= count ? ++_i : --_i) {
        angle = this['circleStartAngle'] + i * angleStep;
        _results.push(new mxn.LatLonPoint(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle)));
      }
      return _results;
    };

    p.generatePtsSpiral = function(count, centerPt) {
      var angle, i, legLength, pt, _i, _results;

      legLength = this['spiralLengthStart'];
      angle = 0;
      _results = [];
      for (i = _i = 0; 0 <= count ? _i < count : _i > count; i = 0 <= count ? ++_i : --_i) {
        angle += this['spiralFootSeparation'] / legLength + i * 0.0005;
        pt = new mxn.LatLonPoint(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle));
        legLength += twoPi * this['spiralLengthFactor'] / angle;
        _results.push(pt);
      }
      return _results;
    };

    p.spiderListener = function(marker) {
      var m, mPt, markerPt, markerSpiderfied, nDist, nearbyMarkerData, nonNearbyMarkers, pxSq, _i, _len, _ref;

      markerSpiderfied = marker['_omsData'] != null;
      if (!(markerSpiderfied && this['keepSpiderfied'])) {
        this['unspiderfy']();
      }
      if (markerSpiderfied || this.map.getMapType() === 'GoogleEarthAPI') {
        return this.trigger('click', marker);
      } else {
        nearbyMarkerData = [];
        nonNearbyMarkers = [];
        nDist = this['nearbyDistance'];
        pxSq = nDist * nDist;
        markerPt = this.llToPt(marker.location);
        _ref = this.markers;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          m = _ref[_i];
          mPt = this.llToPt(m.location);
          if (this.ptDistanceSq(mPt, markerPt) < pxSq) {
            nearbyMarkerData.push({
              marker: m,
              markerPt: mPt
            });
          } else {
            nonNearbyMarkers.push(m);
          }
        }
        if (nearbyMarkerData.length === 1) {
          return this.trigger('click', marker);
        } else {
          return this.spiderfy(nearbyMarkerData, nonNearbyMarkers);
        }
      }
    };

    p['markersNearMarker'] = function(marker, firstOnly) {
      var m, mPt, markerPt, markers, nDist, pxSq, _i, _len, _ref, _ref1, _ref2;

      if (firstOnly == null) {
        firstOnly = false;
      }
      if (this.projHelper.getProjection() == null) {
        throw "Must wait for 'idle' event on map before calling markersNearMarker";
      }
      nDist = this['nearbyDistance'];
      pxSq = nDist * nDist;
      markerPt = this.llToPt(marker.location);
      markers = [];
      _ref = this.markers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        m = _ref[_i];
        if (m === marker || (m.map == null) || !m.getVisible()) {
          continue;
        }
        mPt = this.llToPt((_ref1 = (_ref2 = m['_omsData']) != null ? _ref2.usualPosition : void 0) != null ? _ref1 : m.location);
        if (this.ptDistanceSq(mPt, markerPt) < pxSq) {
          markers.push(m);
          if (firstOnly) {
            break;
          }
        }
      }
      return markers;
    };

    p['markersNearAnyOtherMarker'] = function() {
      var i, i1, i2, m, m1, m1Data, m2, m2Data, mData, nDist, pxSq, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _results;

      if (this.projHelper.getProjection() == null) {
        throw "Must wait for 'idle' event on map before calling markersNearAnyOtherMarker";
      }
      nDist = this['nearbyDistance'];
      pxSq = nDist * nDist;
      mData = (function() {
        var _i, _len, _ref, _ref1, _ref2, _results;

        _ref = this.markers;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          m = _ref[_i];
          _results.push({
            pt: this.llToPt((_ref1 = (_ref2 = m['_omsData']) != null ? _ref2.usualPosition : void 0) != null ? _ref1 : m.location),
            willSpiderfy: false
          });
        }
        return _results;
      }).call(this);
      _ref = this.markers;
      for (i1 = _i = 0, _len = _ref.length; _i < _len; i1 = ++_i) {
        m1 = _ref[i1];
        if (!((m1.map != null) && m1.getVisible())) {
          continue;
        }
        m1Data = mData[i1];
        if (m1Data.willSpiderfy) {
          continue;
        }
        _ref1 = this.markers;
        for (i2 = _j = 0, _len1 = _ref1.length; _j < _len1; i2 = ++_j) {
          m2 = _ref1[i2];
          if (i2 === i1) {
            continue;
          }
          if (!((m2.map != null) && m2.getVisible())) {
            continue;
          }
          m2Data = mData[i2];
          if (i2 < i1 && !m2Data.willSpiderfy) {
            continue;
          }
          if (this.ptDistanceSq(m1Data.pt, m2Data.pt) < pxSq) {
            m1Data.willSpiderfy = m2Data.willSpiderfy = true;
            break;
          }
        }
      }
      _ref2 = this.markers;
      _results = [];
      for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
        m = _ref2[i];
        if (mData[i].willSpiderfy) {
          _results.push(m);
        }
      }
      return _results;
    };

    p.makeHighlightListenerFuncs = function(marker) {
      var _this = this;

      return {
        highlight: function() {
          marker['_omsData'].leg.setColor(_this['legColors']['highlighted'][_this.map.getMapType()]);
          return marker['_omsData'].leg.setAttribute('zIndex', _this['highlightedLegZIndex']);
        },
        unhighlight: function() {
          marker['_omsData'].leg.setColor(_this['legColors']['usual'][_this.map.mapTypeId]);
          return marker['_omsData'].leg.setAttribute('zIndex', _this['usualLegZIndex']);
        }
      };
    };

    p.spiderfy = function(markerData, nonNearbyMarkers) {
      var bodyPt, footLl, footPt, footPts, highlightListenerFuncs, leg, marker, md, nearestMarkerDatum, numFeet, spiderfiedMarkers;

      this.spiderfying = true;
      numFeet = markerData.length;
      bodyPt = this.ptAverage((function() {
        var _i, _len, _results;

        _results = [];
        for (_i = 0, _len = markerData.length; _i < _len; _i++) {
          md = markerData[_i];
          _results.push(md.markerPt);
        }
        return _results;
      })());
      footPts = numFeet >= this['circleSpiralSwitchover'] ? this.generatePtsSpiral(numFeet, bodyPt).reverse() : this.generatePtsCircle(numFeet, bodyPt);
      spiderfiedMarkers = (function() {
        var _i, _len, _results,
          _this = this;

        _results = [];
        for (_i = 0, _len = footPts.length; _i < _len; _i++) {
          footPt = footPts[_i];
          footLl = this.ptToLl(footPt);
          nearestMarkerDatum = this.minExtract(markerData, function(md) {
            return _this.ptDistanceSq(md.markerPt, footPt);
          });
          marker = nearestMarkerDatum.marker;
          leg = new mxn.Polyline([marker.location, footLl]);
          leg.setColor(this['legColors']['usual'][this.map.getMapType()]);
          leg.setWidth(this['legWeight']);
          leg.setAttribute('zIndex', this['usualLegZIndex']);
          this.map.addPolyline(leg);
          marker['_omsData'] = {
            usualPosition: marker.location,
            leg: leg
          };
          if (this['legColors']['highlighted'][this.map.getMapType()] !== this['legColors']['usual'][this.map.getMapType()]) {
            highlightListenerFuncs = this.makeHighlightListenerFuncs(marker);
            marker['_omsData'].hightlightListeners = {
              highlight: marker.addEventListener('mouseover', highlightListenerFuncs.highlight),
              unhighlight: marker.addEventListener('mouseout', highlightListenerFuncs.unhighlight)
            };
          }
          marker.lat = footLl.lat;
          marker.lon = marker.lng = footLl.lon;
          marker.setAttribute('zIndex', Math.round(this['spiderfiedZIndex'] + footPt.y));
          _results.push(marker);
        }
        return _results;
      }).call(this);
      delete this.spiderfying;
      this.spiderfied = true;
      return this.trigger('spiderfy', spiderfiedMarkers, nonNearbyMarkers);
    };

    p['unspiderfy'] = function(markerNotToMove) {
      var listeners, marker, nonNearbyMarkers, unspiderfiedMarkers, _i, _len, _ref;

      if (markerNotToMove == null) {
        markerNotToMove = null;
      }
      if (this.spiderfied == null) {
        return this;
      }
      this.unspiderfying = true;
      unspiderfiedMarkers = [];
      nonNearbyMarkers = [];
      _ref = this.markers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        marker = _ref[_i];
        if (marker['_omsData'] != null) {
          this.map.removePolyline(marker['_omsData'].leg);
          if (marker !== markerNotToMove) {
            marker.lat = marker['_omsData'].usualPosition.lat;
          }
          if (marker !== markerNotToMove) {
            marker.lon = marker.lng = marker['_omsData'].usualPosition.lon;
          }
          marker.setAttribute('zIndex', null);
          listeners = marker['_omsData'].hightlightListeners;
          if (listeners != null) {
            marker.removeEventListener(listeners.highlight);
            marker.removeEventListener(listeners.unhighlight);
          }
          delete marker['_omsData'];
          unspiderfiedMarkers.push(marker);
        } else {
          nonNearbyMarkers.push(marker);
        }
      }
      delete this.unspiderfying;
      delete this.spiderfied;
      this.trigger('unspiderfy', unspiderfiedMarkers, nonNearbyMarkers);
      return this;
    };

    p.ptDistanceSq = function(pt1, pt2) {
      var dx, dy;

      dx = pt1.x - pt2.x;
      dy = pt1.y - pt2.y;
      return dx * dx + dy * dy;
    };

    p.ptAverage = function(pts) {
      var numPts, pt, sumX, sumY, _i, _len;

      sumX = sumY = 0;
      for (_i = 0, _len = pts.length; _i < _len; _i++) {
        pt = pts[_i];
        sumX += pt.x;
        sumY += pt.y;
      }
      numPts = pts.length;
      return new mxn.LatLonPoint(sumX / numPts, sumY / numPts);
    };

    p.llToPt = function(ll) {
      return ll.toProprietary(this.map.api);
    };

    p.ptToLl = function(pt) {
      return mxn.LatLonPoint(0, 0).fromProprietary(this.map.api, pt);
    };

    p.minExtract = function(set, func) {
      var bestIndex, bestVal, index, item, val, _i, _len;

      for (index = _i = 0, _len = set.length; _i < _len; index = ++_i) {
        item = set[index];
        val = func(item);
      }
      if ((typeof bestIndex === "undefined" || bestIndex === null) || val < bestVal) {
        bestVal = val;
        bestIndex = index;
      }
      return set.splice(bestIndex, 1)[0];
    };

    p.arrIndexOf = function(arr, obj) {
      var i, o, _i, _len;

      if (arr.indexOf != null) {
        return arr.indexOf(obj);
      }
      for (i = _i = 0, _len = arr.length; _i < _len; i = ++_i) {
        o = arr[i];
        if (o === obj) {
          return i;
        }
      }
      return -1;
    };

    return _Class;

  })();

}).call(this);
